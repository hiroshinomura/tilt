<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Human Flight Adventure</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;touch-action:none}
    body,html{overflow:hidden;touch-action:none}
    canvas{display:block;background:#87CEEB;touch-action:none}
    #ui{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;font:bold 24px sans-serif;color:#fff;text-shadow:1px 1px 2px #000;z-index:10}
    #story{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font:bold 36px sans-serif;color:yellow;text-shadow:2px 2px 4px #000;white-space:pre-wrap;text-align:center;z-index:10}
  </style>
</head>
<body>
  <div id="ui">
    <div id="stage">Stage: 1</div>
    <div id="score">0</div>
    <div id="hp">HP: 100</div>
  </div>
  <div id="story" style="display:none"></div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
    const ui = { stage: document.getElementById('stage'), score: document.getElementById('score'), hp: document.getElementById('hp') };
    const storyEl = document.getElementById('story');
    let lastDamageTime = 0, lastTiltTime = 0, touchStartY = null;
    const tiltThreshold = -15;
    function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
    window.addEventListener('resize', resize); resize();

    // Player
    const player = { x:80, y:0, vy:0, gravity:0.6, jump:-6, r:15 };
    let pipes = [], items = [], enemies = [];
    let frame = 0, score = 0, hp = 100;
    let stage = 1, startTime = Date.now();
    let flash = 0, shake = 0, running = true, storyActive = false, storyStart = 0;
    const storyTexts = [
      'バナナワニ地獄！ワニがバナナ殴り込み！',
      'リンゴ狐の百鬼夜行！りんごの雨に気をつけろ！',
      'ぶどうクマのバラエティショー開幕！踏まれる前に逃げろ！',
      'ライオンとパイナップルの熱帯嵐が襲来！',
      'キリンとメロンの高所バトル！首を振り回す影を避けろ！',
      'サルがバナナロケットを発射中！炎に巻き込まれるな！',
      'ヘビとイチゴジャムの沼が出現！沈まぬよう飛べ！',
      'ゾウがスイカ大砲を撃ってくる！爆風に飲まれるな！',
      'コウモリとブドウの暗闇侵略！視界ゼロの中を通り抜けろ！',
      '最終章：マンモスとメロン彗星の大決戦！人類の未来を賭けろ！'
    ];
    const fruits = ['#e74c3c','#f1c40f','#8e44ad'];
    const animalColors = ['#a52a2a','#808080','#ffa500'];

    // Drawing Helpers
    function drawPlayer(){
      const x = player.x, y = player.y;
      // Head
      ctx.fillStyle = '#fcd7b6'; ctx.beginPath(); ctx.arc(x,y,player.r,0,2*Math.PI); ctx.fill();
      // Body
      ctx.fillStyle = '#00008B'; ctx.fillRect(x-player.r*0.5,y+player.r*0.5,player.r,player.r*1.5);
      // Limbs
      ctx.strokeStyle='#000'; ctx.lineWidth=3;
      ctx.beginPath(); // legs
      ctx.moveTo(x-player.r*0.2,y+player.r*2); ctx.lineTo(x-player.r*0.2,y+player.r*2.5);
      ctx.moveTo(x+player.r*0.2,y+player.r*2); ctx.lineTo(x+player.r*0.2,y+player.r*2.5);
      ctx.stroke();
    }
    function drawFruit(it){
      const x=it.x,y=it.y;
      ctx.save(); ctx.translate(x,y);
      switch(it.type){
        case 0: // Apple
          ctx.fillStyle=fruits[0]; ctx.beginPath(); ctx.arc(0,0,12,0,2*Math.PI); ctx.fill();
          ctx.fillStyle='#2c3e50'; ctx.fillRect(-2,-12,4,8);
          break;
        case 1: // Banana
          ctx.fillStyle=fruits[1]; ctx.beginPath(); ctx.moveTo(-15,0);
          ctx.quadraticCurveTo(0,-20,20,-10);
          ctx.quadraticCurveTo(0,0,-15,15);
          ctx.fill(); break;
        case 2: // Grape
          ctx.fillStyle=fruits[2];
          for(let dx=-8;dx<=8;dx+=8)for(let dy=-8;dy<=8;dy+=8){ctx.beginPath();ctx.arc(dx,dy,6,0,2*Math.PI);ctx.fill();}
          break;
      }
      ctx.restore();
    }
    function drawEnemy(en){
      const x=en.x,y=en.y,w=en.w,h=en.h;
      ctx.save(); ctx.translate(x,y);
      switch(en.type){
        case 0: // Bear
          ctx.fillStyle=animalColors[0]; ctx.beginPath(); ctx.arc(w/2,h/2,w/2,0,2*Math.PI); ctx.fill(); break;
        case 1: // Lion
          ctx.fillStyle=animalColors[1]; ctx.beginPath(); ctx.arc(w/2,h/2,w/2,0,2*Math.PI); ctx.fill();
          ctx.strokeStyle='#f39c12'; ctx.lineWidth=3; ctx.stroke(); break;
        case 2: // Giraffe
          ctx.fillStyle=animalColors[2]; ctx.fillRect(0,0,w,h);
          ctx.fillStyle='#000'; for(let i=0;i<4;i++){ctx.fillRect(i*(w/4)+2,2,3,3);} break;
      }
      ctx.restore();
    }

    // Game Functions
    function init(){player.y=canvas.height/2;player.vy=0;pipes=[];items=[];enemies=[];frame=0;score=0;hp=100;stage=1;startTime=Date.now();flash=0;shake=0;lastDamageTime=0;lastTiltTime=0;running=true;storyActive=false;storyEl.style.display='none';updateUI();setupOrientation();}
    function updateUI(){ui.score.textContent=score;ui.hp.textContent=`HP: ${hp}`;ui.stage.textContent=`Stage: ${stage}`;}
    function spawnPipe(){const gap=210;const topH=Math.random()*(canvas.height-gap-80)+40;pipes.push({x:canvas.width,topH,bottomY:topH+gap,scored:false});}
    function spawnItem(){if(Math.random()<1/3)items.push({x:canvas.width,y:Math.random()*(canvas.height-50)+25,collected:false,type:Math.floor(Math.random()*3)});}
    function spawnEnemies(){for(let i=0;i<Math.min(stage*2,20);i++){const type=Math.floor(Math.random()*3),size=20+type*10;enemies.push({x:canvas.width+i*30,y:Math.random()*(canvas.height-size),w:size,h:size,type});}}
    function handleCollision(dmg=10){const now=Date.now();if(!running||now-lastDamageTime<500)return;lastDamageTime=now;hp=Math.max(0,hp-dmg);flash=20;shake=20;updateUI();navigator.vibrate?.(50);if(hp<=0)doGameOver();}
    function doGameOver(){running=false;showStory('Game Over! Restarting...');setTimeout(init,5000);}
    function startStory(){running=false;storyActive=true;storyStart=Date.now();storyEl.textContent=storyTexts[(stage-1)%storyTexts.length];storyEl.style.display='block';}
    function endStory(){storyActive=false;storyEl.style.display='none';stage++;startTime=Date.now();updateUI();running=true;}
    function showStory(txt){storyActive=true;storyStart=Date.now();storyEl.textContent=txt;storyEl.style.display='block';}
    function onOrientation(e){const now=Date.now();if(!running||storyActive)return;const beta=e.beta||0;if(beta<tiltThreshold&&now-lastTiltTime>500){player.vy=player.jump;lastTiltTime=now;}}
    function setupOrientation(){if(window.DeviceOrientationEvent&&typeof DeviceOrientationEvent.requestPermission==='function'){DeviceOrientationEvent.requestPermission().then(p=>{if(p==='granted')window.addEventListener('deviceorientation',onOrientation);}).catch(console.error);}else window.addEventListener('deviceorientation',onOrientation);}
    window.addEventListener('touchstart',e=>{touchStartY=e.touches[0].clientY;});
    window.addEventListener('touchend',e=>{const endY=e.changedTouches[0].clientY;if(touchStartY-endY>30&&running&&!storyActive)player.vy=player.jump;});
    window.addEventListener('pointerdown',()=>{if(running&&!storyActive)player.vy=player.jump;});
    window.addEventListener('keydown',e=>{if(running&&!storyActive&&e.code==='Space')player.vy=player.jump;});

    function loop(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const now=Date.now();
      if(storyActive){if(now-storyStart>5000)endStory();requestAnimationFrame(loop);return;}
      if(running&&now-startTime>20000){startStory();requestAnimationFrame(loop);return;}
      ctx.save();
      if(shake-->0)ctx.translate((Math.random()-0.5)*10,0);
      if(flash-->0){ctx.fillStyle=`rgba(255,255,0,${(flash/20)*0.5})`;ctx.fillRect(0,0,canvas.width,canvas.height);}
      frame++;
      // pipe interval doubled
      const pipeInt = Math.max(30, (120 - stage*10) / 2);
      if(frame === pipeInt/2 || frame % pipeInt === 0) spawnPipe();
      // 2x wall freq: spawnPipe twice
      if(frame === pipeInt/2 || frame % pipeInt === 0) spawnPipe();
      if(frame % pipeInt === 0) spawnItem();
      // enemy freq 3x
      const enemyInt = Math.max(200,300-stage*20);
      if(frame % enemyInt === 0) for(let k=0;k<3;k++) spawnEnemies();
      // speed increases 1.2x per stage
      const baseSpeed = 4;
      const pipeSpeed = baseSpeed * Math.pow(1.2, stage-1);
      const enemySpeed = 6 * Math.pow(1.2, stage-1);

      player.vy += player.gravity;
      player.y += player.vy;
      if(player.y + player.r*2 > canvas.height){ player.y = canvas.height-player.r*2; player.vy = 0; handleCollision(); }
      if(player.y < 0){ player.y = 0; player.vy = 0; }

      pipes = pipes.filter(p => {
        p.x -= pipeSpeed;
        if(!p.scored && p.x + 50 < player.x){ score++; p.scored=true; updateUI(); }
        if(player.x < p.x+50 && player.x+player.r*2>p.x && (player.y < p.topH || player.y+player.r*2>p.bottomY)) handleCollision();
        return p.x+50>0;
      });
      items = items.filter(it=>{
        it.x -= pipeSpeed;
        if(!it.collected && player.x<it.x+15 && player.x+player.r*2>it.x-15 && player.y<it.y+15 && player.y+player.r*2>it.y-15){ it.collected=true; hp=100; updateUI(); }
        return it.x+15>0 && !it.collected;
      });
      enemies = enemies.filter(en=>{
        en.x -= enemySpeed;
        if(player.x<en.x+en.w && player.x+player.r*2>en.x && player.y<en.y+en.h && player.y+player.r*2>en.y) handleCollision(20);
        return en.x+en.w>0;
      });
      // draw
      pipes.forEach(p=>{ctx.fillStyle='#0a0';ctx.fillRect(p.x,0,50,p.topH);ctx.fillRect(p.x,p.bottomY,50,canvas.height-p.bottomY);});
      items.forEach(it=>drawFruit(it));
      enemies.forEach(en=>drawEnemy(en));
      drawPlayer();
      ctx.restore();
      requestAnimationFrame(loop);
    }
    init(); loop();
  </script>
</body>
</html>
