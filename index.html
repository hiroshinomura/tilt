<!--
Project: **Baby Flight Adventure** – Flappy‑Bird 型ブラウザゲーム（HTML Canvas + JavaScript）
Author: ChatGPT & user collaborative session

================= 概要 =================
* プレイヤー: 赤ちゃん（約30パーツで構成されたドローイング）
* 敵      : 大雨（雲+雨滴）、ネギ（球根+葉）、虫（胴体+脚）
* 回復    : ピアノ（鍵盤のみ）、アイス、寿司  ─ 各30パーツ描画
* 操作    : スワイプ/タップ/スペース/傾きでジャンプ（3連続で大ジャンプ）
* UI      : HP, Stage, Score 表示。20秒毎にステージ切替＋音声読み上げ。
* 難易度  : ステージ毎に1.2×スクロール速度。敵は 10% 確率で生成。

================= 既知の課題 =================
☐ 描画負荷軽減, ☒ 敵頻度調整, ☒ コメント整備
-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <title>Baby Flight Adventure</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;touch-action:none}
    html,body{overflow:hidden;height:100%;}
    canvas{display:block;width:100%;height:100%;background:#87CEEB}
    #ui{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;font:bold 24px sans-serif;color:#fff;text-shadow:1px 1px 2px #000;z-index:10}
    #story{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font:bold 32px sans-serif;color:hotpink;text-shadow:2px 2px 4px #000;white-space:pre-wrap;text-align:center;z-index:10}
  </style>
</head>
<body>
  <div id="ui"><div id="stage">Stage: 1</div><div id="score">0</div><div id="hp">HP: 100</div></div>
  <div id="story" style="display:none"></div>
  <canvas id="game"></canvas>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}window.addEventListener('resize',resize);resize();
//------------------ game state ------------------
let pipes=[],items=[],enemies=[];
let frame=0,score=0,hp=100,stage=1,startTime=Date.now();
let flash=0,shake=0,running=true,storyActive=false,storyStart=0;
const player={x:80,y:0,vy:0,gravity:0.6,jump:-6,double:-12,r:20};
const storyTexts=[
  'Stage1: 赤ちゃんと鍵盤ピアノ！大雨が迫る！アイスでひと休み！',
  'Stage2: ネギの嵐到来！寿司でパワー回復！',
  'Stage3: 虫大襲来！ピアノ演奏で撃退せよ！',
  'Stage4: 三重苦！アイスが救いの光！',
  'Stage5: 寿司リサイタルが敵を魅了！',
  'Stage6: ネギ竜巻と虫の大合唱！',
  'Stage7: 鍵盤の雨音で大雨を和らげろ！',
  'Stage8: 虫に囲まれても寿司が待っている！',
  'Stage9: ネギVSアイスVS寿司、究極のバトル！',
  'Final: 赤ちゃんVS三大天災！勝者は？'];
const ui={stage:document.getElementById('stage'),score:document.getElementById('score'),hp:document.getElementById('hp')};
const storyEl=document.getElementById('story');
function updateUI(){ui.stage.textContent=`Stage: ${stage}`;ui.score.textContent=score;ui.hp.textContent=`HP: ${hp}`;}
//------------------ draw helpers ------------------
function drawPlayer(){const {x,y,r}=player;ctx.fillStyle='#FBE8EB';ctx.beginPath();ctx.arc(x,y,r,0,2*Math.PI);ctx.fill();//hair
for(let i=0;i<30;i++){const ang=i/30*2*Math.PI;ctx.strokeStyle='#A65F3F';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(x+Math.cos(ang)*r*0.6,y-Math.sin(ang)*r*0.6);ctx.lineTo(x+Math.cos(ang)*r*0.9,y-Math.sin(ang)*r*0.9);ctx.stroke();}
ctx.fillStyle='#000';ctx.beginPath();ctx.arc(x-5,y-5,3,0,2*Math.PI);ctx.arc(x+5,y-5,3,0,2*Math.PI);ctx.fill();ctx.fillStyle='#EAB8A5';ctx.fillRect(x-3,y+2,6,3);ctx.strokeStyle='#D66';ctx.beginPath();ctx.arc(x,y+8,6,0,Math.PI);ctx.stroke();}
function drawItem(it){const {x,y,type}=it;if(type===0){for(let i=0;i<30;i++){ctx.fillStyle=i%2?'#000':'#fff';ctx.fillRect(x-30+i*2,y-5,2,30);}}else if(type===1){for(let i=0;i<30;i++){ctx.fillStyle=`hsl(${200+i*2},60%,${60-i}% )`;ctx.beginPath();ctx.arc(x+Math.cos(i)*5,y-15+Math.sin(i)*5,4,0,2*Math.PI);ctx.fill();}}else{for(let i=0;i<30;i++){ctx.fillStyle=i<20?'#fff':'#0A3';ctx.beginPath();ctx.arc(x+Math.random()*30-15,y+Math.random()*10-5,3,0,2*Math.PI);ctx.fill();}}}
function drawEnemy(en){const {x,y,type}=en;const sz=20;if(type===0){ctx.fillStyle='#EEE';ctx.beginPath();ctx.arc(x,y,sz,Math.PI,2*Math.PI);ctx.arc(x+sz*0.6,y,sz*0.8,Math.PI,2*Math.PI);ctx.arc(x+sz*1.2,y,sz,Math.PI,2*Math.PI);ctx.fill();ctx.strokeStyle='#06F';ctx.lineWidth=2;for(let i=0;i<15;i++){const dx=x-sz*1.2+Math.random()*sz*2.4;ctx.beginPath();ctx.moveTo(dx,y);ctx.lineTo(dx,y+sz);ctx.stroke();}}else if(type===1){ctx.fillStyle='#FFF';ctx.beginPath();ctx.ellipse(x,y+sz/4,sz/2,sz/3,0,0,Math.PI*2);ctx.fill();for(let i=0;i<10;i++){const ang=-Math.PI/2+(i-5)*0.1;ctx.strokeStyle=`hsl(120,80%,${40+i*4}%)`;ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(x,y+sz/4);ctx.lineTo(x+Math.cos(ang)*sz,y+sz/4+Math.sin(ang)*sz);ctx.stroke();}}else{ctx.fillStyle='#000';ctx.beginPath();ctx.arc(x,y,sz/2,0,2*Math.PI);ctx.fill();for(let i=0;i<6;i++){const a=i*Math.PI/3;ctx.strokeStyle='#000';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(x+Math.cos(a)*sz/2,y+Math.sin(a)*sz/2);ctx.lineTo(x+Math.cos(a)*sz*0.8,y+Math.sin(a)*sz*0.8);ctx.stroke();}}}
//------------------ spawn ------------------
function spawnPipe(){const gap=256;const topH=Math.random()*(canvas.height-gap-80)+40;pipes.push({x:canvas.width,topH,bottomY:topH+gap,scored:false});}
function spawnItem(){if(Math.random()<1/3){items.push({x:canvas.width,y:Math.random()*(canvas.height-50)+25,type:frame%3});}}
function spawnEnemy(){const type=frame%3;enemies.push({x:canvas.width,y:Math.random()*(canvas.height-20),w:20,h:20,type});}
//------------------ story ------------------
function showStory(txt){storyActive=true;storyStart=Date.now();storyEl.textContent=txt;storyEl.style.display='block';speechSynthesis.speak(new SpeechSynthesisUtterance(txt));}
function startStory(){running=false;showStory(storyTexts[(stage-1)%storyTexts.length]);}
function endStory(){storyActive=false;storyEl.style.display='none';stage++;startTime=Date.now();updateUI();running=true;}
function doGameOver(){running=false;showStory('Game Over! Restarting...');setTimeout(init,5000);}
//------------------ input ------------------
let touchStartY,tapCount=0,lastTap=0;
function performJump(){const now=Date.now();tapCount=now-lastTap<400?tapCount+1:1;lastTap=now;player.vy=tapCount>=3?player.double:player.jump;}
window.addEventListener('pointerdown',e=>{if(running&&!storyActive)performJump();});
window.addEventListener('keydown',e=>{if(e.code==='Space'&&running&&!storyActive)performJump();});
window.addEventListener('touchstart',e=>touchStartY=e.touches[0].clientY);
window.addEventListener('touchend',e=>{if(touchStartY-e.changedTouches[0].clientY>30&&running&&!storyActive)performJump();});
//------------------ loop ------------------
function init(){player.y=canvas.height/2;player.vy=0;pipes=[];items=[];enemies=[];frame=0;score=0;hp=100;stage=1;startTime=Date.now();flash=0;shake=0;storyActive=false;updateUI();}
let lastDamage=0;
function handleCollision(dmg=10){const now=Date.now();if(now-lastDamage<500||!running)return;lastDamage=now;hp=Math.max(0,hp-dmg);flash=20;shake=20;updateUI();if(hp<=0)doGameOver();}
function loop(){ctx.clearRect(0,0,canvas.width,canvas.height);const now=Date.now();if(storyActive){if(now-storyStart>5000)endStory();requestAnimationFrame(loop);return;}if(running&&now-startTime>20000){startStory();requestAnimationFrame(loop);return;}
ctx.save();if(shake-->0)ctx.translate((Math.random()-0.5)*10,0);if(flash-->0){ctx.fillStyle=`rgba(255,255,0,${flash/20*0.5})`;ctx.fillRect(0,0,canvas.width,canvas.height);}frame++;const stageSpeed=Math.pow(1.2,stage-1);
// spawn
const pipeInt=Math.max(30,(120-stage*10)/2);if(frame%pipeInt===0){spawnPipe();spawnPipe();spawnItem();}
const enemyBase=Math.max(200,300-stage*20);const enemyInterval=Math.max(1,Math.floor(enemyBase/270));if(frame%enemyInterval===0&&Math.random()<0.1)spawnEnemy();
// speeds
const pipeSpeed=4*stageSpeed,enemySpeed=6*stageSpeed;
// update player
player.vy+=player.gravity;player.y+=player.vy;if(player.y+player.r*2>canvas.height){player.y=canvas.height-player.r*2;player.vy=0;handleCollision();}if(player.y<0){player.y=0;player.vy=0;}
// draw player
drawPlayer();
// update lists
pipes=pipes.filter(p=>{p.x-=pipeSpeed;if(!p.scored&&p.x+50<player.x){score++;p.scored=true;updateUI();}ctx.fillStyle='#0a0';ctx.fillRect(p.x,0,50,p.topH);ctx.fillRect(p.x,p.bottomY,50,canvas.height-p.bottomY);
        // collision with pipe
        if(player.x < p.x + 50 && player.x + player.r*2 > p.x && (player.y < p.topH || player.y + player.r*2 > p.bottomY)) {
          handleCollision(10);
        }
        return p.x + 50 > 0;});
items=items.filter(it=>{it.x-=pipeSpeed;drawItem(it);if(Math.abs(player.x-it.x)<20&&Math.abs(player.y-it.y)<20){hp=100;updateUI();return false;}return it.x> -40;});
enemies=enemies.filter(en=>{en.x-=enemySpeed;drawEnemy(en);if(Math.abs(player.x-en.x)<20&&Math.abs(player.y-en.y)<20)handleCollision(20);return en.x> -40;});
ctx.restore();requestAnimationFrame(loop);}init();loop();
</script>
</body>
</html>
